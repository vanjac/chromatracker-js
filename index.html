<!DOCTYPE html>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
  body {
    width: 100%;
    height: 100%;
    margin:0;
    overflow: hidden;
    position: fixed;
  }
  td {
    border: 1px solid black;
  }
  .sel-cell {
    background: pink;
  }
  .hilite-row {
    background: lightblue;
  }
</style>

<script src="src/Module.js"></script>
<script src="src/PeriodTable.js"></script>
<script src="src/ModLoader.js"></script>
<script src="src/ModWriter.js"></script>
<script src="src/Playback.js"></script>
<script src="src/PatternView.js"></script>
<script src="src/PatternEdit.js"></script>

<div>
  <input id="file-select" type="file">
  <button onclick="loadFile()">Load</button>
  <button onclick="saveFile()">Save</button>
</div>
<div>
  <button onclick="play()">Play</button>
  <button onclick="play(true)">Play from</button>
  <button onclick="stop()">Stop</button>
  <button onclick="patternZap()">Pattern Zap</button>
</div>
<div>Title: <span id="title"></span></div>
<select id="sequence" size="10" style="width:30pt"></select>
<select id="samples" size="10" style="width:130pt"></select>
<div>Row: <input style="width:36pt;" type="number" id="row"></div>
<div>
  Tempo: <input style="width:36pt;" type="number" id="tempo">
  Speed: <input style="width:36pt;" type="number" id="speed">
</div>
<div>Active samplers: <span id="samplers"></span></div>
<div>Time: <span id="time"></span></div>
<div>Queued time: <span id="queued"></span></div>
<div>
  <input type="checkbox" onchange="muteCheck(0, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(1, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(2, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(3, this.checked)" checked>
</div>
<div style="display:flex">
  <label for="pitch-enable">Pitch</label>
  <input type="checkbox" checked id="pitch-enable">
  <input style="flex-grow:1" type="range" min="0" max="59" id="jam-pitch-range"
    oninput="query('#jam-pitch').value=this.value;jamUp();jamDown()"
    onmousedown="jamDown()" onmouseup="jamUp()" ontouchstart="jamDown()" ontouchend="jamUp()">
  <input style="width:36pt;" type="number" value="36" id="jam-pitch" oninput="query('#jam-pitch-range').value=this.value">
</div>
<div>
  <select id="effect">
    <option>0: Arpeggio</option>
    <option>1: Port Up</option>
    <option>2: Port Down</option>
    <option>3: Tone Port</option>
    <option>4: Vibrato</option>
    <option>5: Volslide+Toneport</option>
    <option>6: Volslide+Vibrato</option>
    <option>7: Tremolo</option>
    <option>8: Panning</option>
    <option>9: Offset</option>
    <option>A: Volume Slide</option>
    <option>B: Position Jump</option>
    <option>C: Volume</option>
    <option>D: Pattern Break</option>
    <option>E: Extended</option>
    <option>F: Tempo</option>
  </select>
  <select id="param0">
    <option>0</option>
    <option>1</option>
    <option>2</option>
    <option>3</option>
    <option>4</option>
    <option>5</option>
    <option>6</option>
    <option>7</option>
    <option>8</option>
    <option>9</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
    <option>D</option>
    <option>E</option>
    <option>F</option>
  </select>
  <select id="param1">
    <option>0</option>
    <option>1</option>
    <option>2</option>
    <option>3</option>
    <option>4</option>
    <option>5</option>
    <option>6</option>
    <option>7</option>
    <option>8</option>
    <option>9</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
    <option>D</option>
    <option>E</option>
    <option>F</option>
  </select>
</div>
<div style="display:flex">
  <button style="flex-grow:1" onmousedown="jamDown(event)" onmouseup="jamUp(event)"
    ontouchstart="jamDown(event)" ontouchend="jamUp(event)">Jam</button>
  <button style="flex-grow:1" onmousedown="jamDown(event); writeCell()" onmouseup="jamUp(event)"
    ontouchstart="jamDown(event); writeCell()" ontouchend="jamUp(event)">Write</button>
  <button style="flex-grow:1" onclick="clearCell()">Clear</button>
  <button style="flex-grow:1" onmousedown="liftCell(); jamDown(event)" onmouseup="jamUp(event)"
    ontouchstart="liftCell(); jamDown(event)" ontouchend="jamUp(event)">Lift</button>
</div>
<div style="height:200pt; overflow-y:auto;">
  <table id="pattern-table" style="font-family:monospace;"></table>
</div>
<div id="errors">
  Errors:<br>
</div>

<script>
  "use strict";

  const query = s => document.querySelector(s);

  window.onerror = (message, source, line) => {
    query('#errors').insertAdjacentHTML('beforeend',
      `${source}:${line}<br>&nbsp;&nbsp;${message}<br>`);
  };

  let module;
  let context;
  let playback;

  let animHandle;
  let intervalHandle;

  let queuedTime = 0;
  let queuedLines = [];

  let curPattern = null;
  let curPatternIdx = -1;
  let selRow = -1;
  let selChannel = -1;

  function loadFile() {
    /** @type File */
    let files = document.querySelector('#file-select').files;
    if (files.length) {
      readModuleBlob(files[0]);
    } else {
      fetch('https://chroma.zone/share/space_debris.mod').then(
        r => r.blob().then(
          b => readModuleBlob(b)));
    }
  }

  function readModuleBlob(blob) {
    let reader = new FileReader();
    reader.onload = () => {
      module = Object.freeze(readModule(reader.result));
      console.log(module);

      query('#title').textContent = module.name;

      refreshSequence();

      let samplesElem = query('#samples');
      samplesElem.textContent = '';
      for (let [i, sample] of module.samples.entries()) {
        let option = document.createElement('option')
        option.textContent = i + ': ' + (sample ? sample.name : '(none)');
        samplesElem.appendChild(option);
      }

      play();
    };
    reader.readAsArrayBuffer(blob);
  }

  function saveFile() {
    let blob = new Blob([writeModule(module)], {type: 'application/octet-stream'});
    window.open(URL.createObjectURL(blob));
  }

  function play(resume) {
    if (!module)
      return;
    if (!context) {
      let AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext({latencyHint: 'interactive'});
    }
    // for iOS:
    context.resume().then(() => {
      if (intervalHandle)
        stop();
      playback = initPlayback(context, module);
      if (resume) {
        playback.pos = query('#sequence').selectedIndex;
        if (playback.pos == -1) playback.pos = 0;
        playback.row = query('#row').valueAsNumber;
        playback.tempo = query('#tempo').valueAsNumber;
        playback.speed = query('#speed').valueAsNumber;
      }

      let process = () => {
        while (queuedTime < context.currentTime + 0.5) {
          queuedTime = playback.time;
          let {pos, row} = playback;
          processRow(playback);
          let {tempo, speed} = playback;
          queuedLines.push({time: queuedTime, pos, row, tempo, speed});
        }
        query('#queued').textContent = queuedTime.toFixed(3);
      };
      process();
      intervalHandle = setInterval(process, 200);

      animHandle = requestAnimationFrame(update);
    })
  }

  function stop() {
    if (intervalHandle) {
      stopPlayback(playback);
      clearInterval(intervalHandle);
      cancelAnimationFrame(animHandle);
      queuedLines = [];
      queuedTime = 0;
      intervalHandle = null;
    }
  }

  function muteCheck(channel, checked) {
    if (playback)
      setChannelMute(playback, channel, !checked);
  }

  function jamDown(e) {
    if (e)
      e.preventDefault();
    if (playback) {
      let s = query('#samples').selectedIndex;
      if (s > 0)
        jamPlay(playback, s, query('#jam-pitch').valueAsNumber);
    }
  }

  function jamUp(e) {
    if (e)
      e.preventDefault();
    if (playback)
      jamRelease(playback);
  }

  function update() {
    animHandle = requestAnimationFrame(update);

    let curTime = context.currentTime;
    if (context.outputLatency) // if supported
      curTime -= context.outputLatency;
    if (queuedLines.length) {
      let i = 0;
      while (i < (queuedLines.length - 1) && queuedLines[i + 1].time <= curTime)
        i++;
      queuedLines.splice(0, i);
      let curLine = queuedLines[0];
      query('#sequence').selectedIndex = curLine.pos;
      query('#row').value = curLine.row;
      query('#tempo').value = curLine.tempo;
      query('#speed').value = curLine.speed;

      curPatternIdx = module.sequence[curLine.pos];
      refreshPattern();
      
      let oldHilite = query('.hilite-row');
      if (oldHilite)
        oldHilite.classList.remove('hilite-row');
      query('#pattern-table').children[curLine.row].classList.add('hilite-row');
    }
    let activeSources = 0;
    for (let channel of playback.channels)
      activeSources += channel.activeSources.size;
    query('#samplers').textContent = activeSources;
    query('#time').textContent = context.currentTime.toFixed(3);
  }

  function refreshSequence() {
    let seqElem = query('#sequence');
    seqElem.textContent = '';
    for (let [i, pos] of module.sequence.entries()) {
      let option = document.createElement('option')
      option.textContent = pos;
      seqElem.appendChild(option);
    }
  }

  function refreshPattern() {
    let pattern = module.patterns[curPatternIdx];
    if (pattern != curPattern) {
      console.log('update pattern');
      curPattern = pattern;
      let table = query('#pattern-table');
      table.textContent = '';
      for (let row = 0; row < numRows; row++) {
        let tr = document.createElement('tr');
        table.appendChild(tr);
        for (let c = 0; c < module.numChannels; c++) {
          const c_row = row, c_c = c;
          let cell = pattern[c][row];
          let td = document.createElement('td');
          td.textContent = cellString(cell);
          td.onclick = () => {
            selRow = c_row;
            selChannel = c_c;
            updateSelCell();
          }
          tr.appendChild(td);
        }
      }
      updateSelCell();
    }
  }

  function updateSelCell() {
    let existing = query('.sel-cell');
    if (existing)
      existing.classList.remove('sel-cell');
    if (selRow >= 0 && selChannel >= 0)
      query('#pattern-table').children[selRow].children[selChannel].classList.add('sel-cell');
  }

  function patternZap() {
    let newMod = Object.assign(new Module(), module);
    newMod.patterns = Object.freeze([...Array(16)].map(() =>
      Object.freeze([...Array(module.numChannels)].map(() =>
        Object.freeze([...Array(numRows)].map(() =>
          Object.freeze(new Cell()))))))); // lisp is so cool
    newMod.sequence = Object.freeze([...Array(16).keys()]);
    module = newMod;
    if (playback)
      playback.module = module;
    refreshSequence();
    refreshPattern();
  }

  function writeCell() {
    let cell = new Cell();
    if (query('#pitch-enable').checked)
      cell.pitch = query('#jam-pitch').valueAsNumber;
    cell.sample = query('#samples').selectedIndex;
    if (cell.sample == -1)
      cell.sample = 0;
    cell.effect = query('#effect').selectedIndex;
    cell.param = query('#param0').selectedIndex << 4;
    cell.param |= query('#param1').selectedIndex;
    module = editPutCell(module, curPatternIdx, selChannel, selRow, Object.freeze(cell));
    if (playback)
      playback.module = module;
    selRow++;
    refreshPattern();
  }

  function clearCell() {
    module = editPutCell(module, curPatternIdx, selChannel, selRow, Object.freeze(new Cell()));
    if (playback)
      playback.module = module;
    selRow++;
    refreshPattern();
  }

  function liftCell() {
    let cell = module.patterns[curPatternIdx][selChannel][selRow];
    query('#pitch-enable').checked = cell.pitch >= 0;
    if (cell.pitch >= 0) {
      query('#jam-pitch').value = cell.pitch;
    }
    if (cell.sample)
      query('#samples').selectedIndex = cell.sample;
    query('#effect').selectedIndex = cell.effect;
    query('#param0').selectedIndex = cell.param >> 4;
    query('#param1').selectedIndex = cell.param & 0xf;
  }
</script>
