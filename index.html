<!DOCTYPE html>

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="src/Module.js"></script>
<script src="src/PeriodTable.js"></script>
<script src="src/ModLoader.js"></script>
<script src="src/Playback.js"></script>

<input id="file-select" type="file">
<button onclick="loadFile()">Load</button><br>
<button onclick="play()">Play</button>
<button onclick="play(true)">Play from</button>
<button onclick="stop()">Stop</button><br>
<div>
  Pos: <input type="number" size="6" id="pos">
  Pat: <span id="pat"></span>
</div>
<div>Row: <input type="number" size="6" id="row"></div>
<div>Tempo: <input type="number" size="6" id="tempo"></div>
<div>Speed: <input type="number" size="6" id="speed"></div>
<div>Active samplers: <span id="samplers"></span></div>
<div>
  <input type="checkbox" onchange="muteCheck(0, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(1, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(2, this.checked)" checked>
  <input type="checkbox" onchange="muteCheck(3, this.checked)" checked>
</div>

<script>
  "use strict";

  const query = s => document.querySelector(s);

  let module;
  let context;
  let playback;

  let animHandle;
  let intervalHandle;

  let queuedTime = 0;
  let queuedLines = [];

  function loadFile() {
    /** @type File */
    let file = document.querySelector('#file-select').files[0];
    file.arrayBuffer().then(b => {
      module = readModule(b);
      console.log(module);
      play();
    });
  }

  function play(resume) {
    if (!module)
      return;
    if (!context)
      context = new AudioContext({latencyHint: 'playback'});
    if (playback)
      stop();
    playback = initPlayback(context, module);
    if (resume) {
      playback.pos = query('#pos').valueAsNumber;
      playback.row = query('#row').valueAsNumber;
      playback.tempo = query('#tempo').valueAsNumber;
      playback.speed = query('#speed').valueAsNumber;
    }

    let process = () => {
      while (queuedTime < context.currentTime + 0.5) {
        queuedTime = playback.time;
        let {pos, row} = playback;
        processRow(playback);
        let {tempo, speed} = playback;
        queuedLines.push({time: queuedTime, pos, row, tempo, speed});
      }
    };
    process();
    intervalHandle = setInterval(process, 200);

    animHandle = requestAnimationFrame(update);
  }

  function stop() {
    if (playback) {
      stopPlayback(playback);
      clearInterval(intervalHandle);
      cancelAnimationFrame(animHandle);
      queuedLines = [];
      playback = null;
    }
  }

  function muteCheck(channel, checked) {
    if (playback)
      setChannelMute(playback, channel, !checked);
  }

  function update() {
    animHandle = requestAnimationFrame(update);

    let curTime = context.currentTime - context.outputLatency;
    if (queuedLines.length) {
      let i = 0;
      while (i < (queuedLines.length - 1) && queuedLines[i + 1].time <= curTime)
        i++;
      queuedLines.splice(0, i);
      let curLine = queuedLines[0];
      query('#pos').value = curLine.pos;
      query('#pat').textContent = playback.mod.sequence[curLine.pos];
      query('#row').value = curLine.row;
      query('#tempo').value = curLine.tempo;
      query('#speed').value = curLine.speed;
    }
    let activeSources = 0;
    for (let channel of playback.channels)
      activeSources += channel.activeSources.size;
    query('#samplers').textContent = activeSources;
  }
</script>
